name: ðŸŽ¯ Performance & Load Testing

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ labeled ]
  schedule:
    # Run performance tests nightly at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      test_duration:
        description: 'Test duration in minutes'
        required: false
        default: '10'
      load_pattern:
        description: 'Load pattern (constant, ramp, spike)'
        required: false
        default: 'ramp'

env:
  JAVA_VERSION: '21'
  K6_VERSION: '0.47.0'

jobs:
  # ðŸŽ¯ Unit Performance Tests
  unit-performance:
    name: ðŸŽ¯ Unit Performance Tests
    runs-on: ubuntu-latest
    if: contains(github.event.label.name, 'performance') || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜• Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'

      - name: ðŸ˜ Setup Gradle
        uses: gradle/gradle-build-action@v2

      - name: ðŸŽ¯ Run Performance Unit Tests
        run: ./gradlew performanceTest --continue
        timeout-minutes: 15

      - name: ðŸ“Š Generate Performance Report
        run: ./gradlew generatePerformanceReport

      - name: ðŸ“‹ Upload Performance Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unit-performance-results
          path: build/reports/performance/

  # ðŸš€ Application Startup Performance
  startup-performance:
    name: ðŸš€ Application Startup Performance
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜• Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'

      - name: ðŸ˜ Setup Gradle
        uses: gradle/gradle-build-action@v2

      - name: ðŸ—ï¸ Build Application
        run: ./gradlew :ktor-server:shadowJar

      - name: â±ï¸ Measure Startup Time
        run: |
          echo "ðŸš€ Measuring application startup time..."
          
          # Start timing
          START_TIME=$(date +%s%N)
          
          # Start application in background
          timeout 60 java -jar ktor-server/build/libs/*-all.jar &
          APP_PID=$!
          
          # Wait for health check to pass
          timeout 60 bash -c 'until curl -f http://localhost:8080/health > /dev/null 2>&1; do sleep 0.1; done'
          
          # Calculate startup time
          END_TIME=$(date +%s%N)
          STARTUP_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
          
          echo "â±ï¸ Application startup time: ${STARTUP_TIME}ms"
          echo "startup_time=${STARTUP_TIME}" >> $GITHUB_OUTPUT
          
          # Stop application
          kill $APP_PID || true
          
          # Check if startup time is acceptable (< 10 seconds)
          if [ $STARTUP_TIME -gt 10000 ]; then
            echo "ðŸš¨ Startup time ${STARTUP_TIME}ms exceeds 10s threshold!"
            exit 1
          fi

  # ðŸŒŠ Load Testing with K6
  load-testing:
    name: ðŸŒŠ Load Testing (K6)
    runs-on: ubuntu-latest
    needs: [startup-performance]
    if: github.ref == 'refs/heads/main' || contains(github.event.label.name, 'performance') || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜• Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'

      - name: ðŸ˜ Setup Gradle
        uses: gradle/gradle-build-action@v2

      - name: ðŸ“¦ Setup K6
        run: |
          curl -L https://github.com/grafana/k6/releases/download/v${{ env.K6_VERSION }}/k6-v${{ env.K6_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv k6-v${{ env.K6_VERSION }}-linux-amd64/k6 /usr/local/bin/

      - name: ðŸ—ï¸ Build and Start Application
        run: |
          ./gradlew :ktor-server:shadowJar
          
          # Start application with performance profiling
          java -XX:+FlightRecorder -XX:StartFlightRecording=duration=30m,filename=performance.jfr \
               -jar ktor-server/build/libs/*-all.jar &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_ENV
          
          # Wait for application to be ready
          timeout 60 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'
        env:
          POSTGRES_URL: jdbc:postgresql://localhost:5432/test
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test

      - name: ðŸŒŠ Run Load Tests
        run: |
          # Create K6 test script
          cat > load-test.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          import { Rate } from 'k6/metrics';

          const errorRate = new Rate('errors');
          const baseUrl = 'http://localhost:8080';

          export let options = {
            stages: [
              { duration: '2m', target: 10 },   // Ramp-up
              { duration: '5m', target: 50 },   // Stay at 50 users
              { duration: '2m', target: 100 },  // Ramp-up to 100 users
              { duration: '5m', target: 100 },  // Stay at 100 users
              { duration: '2m', target: 0 },    // Ramp-down
            ],
            thresholds: {
              http_req_duration: ['p(95)<500', 'p(99)<1000'],
              http_req_failed: ['rate<0.05'],
              errors: ['rate<0.05'],
            },
          };

          export default function() {
            // Health check
            let healthRes = http.get(`${baseUrl}/health`);
            check(healthRes, {
              'health check status is 200': (r) => r.status === 200,
            }) || errorRate.add(1);

            // API endpoints (assuming these exist)
            let apiRes = http.get(`${baseUrl}/api/v1/users`);
            check(apiRes, {
              'users API status is 200': (r) => r.status === 200,
              'users API response time < 500ms': (r) => r.timings.duration < 500,
            }) || errorRate.add(1);

            sleep(1);
          }
          EOF

          # Run the load test
          k6 run --out json=results.json load-test.js

      - name: ðŸ“Š Process Load Test Results
        run: |
          # Extract key metrics from K6 results
          echo "ðŸ“Š Load Test Results:" > performance-summary.txt
          
          # Parse JSON results for key metrics
          if [ -f results.json ]; then
            echo "âœ… Load test completed successfully" >> performance-summary.txt
            
            # You can add more sophisticated result parsing here
            grep -E '"metric":"http_req_duration".*"p\(95\)"' results.json | tail -1 >> performance-summary.txt || echo "P95 response time: Not available" >> performance-summary.txt
            grep -E '"metric":"http_req_failed".*"rate"' results.json | tail -1 >> performance-summary.txt || echo "Error rate: Not available" >> performance-summary.txt
          else
            echo "âŒ Load test results not found" >> performance-summary.txt
          fi
          
          cat performance-summary.txt

      - name: ðŸ›‘ Stop Application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ]; then
            kill $APP_PID || true
            wait $APP_PID 2>/dev/null || true
          fi

      - name: ðŸ“‹ Upload Load Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: load-test-results
          path: |
            results.json
            performance-summary.txt
            performance.jfr

  # ðŸ”¥ Stress Testing
  stress-testing:
    name: ðŸ”¥ Stress Testing
    runs-on: ubuntu-latest
    needs: [load-testing]
    if: github.ref == 'refs/heads/main' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜• Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'

      - name: ðŸ˜ Setup Gradle
        uses: gradle/gradle-build-action@v2

      - name: ðŸ“¦ Setup K6
        run: |
          curl -L https://github.com/grafana/k6/releases/download/v${{ env.K6_VERSION }}/k6-v${{ env.K6_VERSION }}-linux-amd64.tar.gz | tar xz
          sudo mv k6-v${{ env.K6_VERSION }}-linux-amd64/k6 /usr/local/bin/

      - name: ðŸ—ï¸ Build and Start Application
        run: |
          ./gradlew :ktor-server:shadowJar
          java -Xmx512m -jar ktor-server/build/libs/*-all.jar &
          APP_PID=$!
          echo "APP_PID=$APP_PID" >> $GITHUB_ENV
          timeout 60 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'

      - name: ðŸ”¥ Run Stress Test
        run: |
          cat > stress-test.js << 'EOF'
          import http from 'k6/http';
          import { check } from 'k6';

          export let options = {
            stages: [
              { duration: '1m', target: 50 },
              { duration: '2m', target: 200 },
              { duration: '1m', target: 500 },  // Stress level
              { duration: '2m', target: 500 },  // Stay at stress level
              { duration: '1m', target: 0 },
            ],
            thresholds: {
              http_req_failed: ['rate<0.10'], // Allow higher error rate in stress test
            },
          };

          export default function() {
            let res = http.get('http://localhost:8080/health');
            check(res, {
              'status is not 5xx': (r) => r.status < 500,
            });
          }
          EOF

          k6 run --out json=stress-results.json stress-test.js

      - name: ðŸ›‘ Stop Application
        if: always()
        run: |
          if [ ! -z "$APP_PID" ]; then
            kill $APP_PID || true
          fi

      - name: ðŸ“‹ Upload Stress Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: stress-test-results
          path: stress-results.json

  # ðŸ“ˆ Performance Trend Analysis
  performance-analysis:
    name: ðŸ“ˆ Performance Trend Analysis
    runs-on: ubuntu-latest
    needs: [unit-performance, load-testing, stress-testing]
    if: always()
    steps:
      - name: ðŸ“¥ Download Performance Results
        uses: actions/download-artifact@v4
        with:
          pattern: "*-performance-results"
          merge-multiple: true

      - name: ðŸ“¥ Download Load Test Results
        uses: actions/download-artifact@v4
        with:
          name: load-test-results

      - name: ðŸ“Š Generate Performance Summary
        run: |
          echo "## ðŸŽ¯ Performance Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | Status | Key Metrics |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Performance | ${{ needs.unit-performance.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} | Micro-benchmarks |" >> $GITHUB_STEP_SUMMARY
          echo "| Startup Performance | ${{ needs.startup-performance.result == 'success' && 'âœ… < 10s' || 'âš ï¸ > 10s' }} | Application startup |" >> $GITHUB_STEP_SUMMARY
          echo "| Load Testing | ${{ needs.load-testing.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} | 100 concurrent users |" >> $GITHUB_STEP_SUMMARY
          echo "| Stress Testing | ${{ needs.stress-testing.result == 'success' && 'âœ… Resilient' || 'âš ï¸ Degraded' }} | 500 concurrent users |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Performance Thresholds" >> $GITHUB_STEP_SUMMARY
          echo "- **Response Time**: P95 < 500ms, P99 < 1000ms" >> $GITHUB_STEP_SUMMARY
          echo "- **Error Rate**: < 5% under normal load" >> $GITHUB_STEP_SUMMARY
          echo "- **Startup Time**: < 10 seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Throughput**: Sustainable under 100 concurrent users" >> $GITHUB_STEP_SUMMARY
          echo "- **Resilience**: Graceful degradation under stress" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ“ˆ Store Performance Baseline
        if: github.ref == 'refs/heads/main'
        run: |
          # Store performance metrics for trend analysis
          echo "ðŸ“ˆ Storing performance baseline for trend analysis"
          # This would typically integrate with your performance monitoring system
